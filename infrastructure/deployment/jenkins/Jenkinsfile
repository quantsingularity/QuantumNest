pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: worker
    security-zone: restricted
    compliance: financial
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  containers:
  - name: docker
    image: docker:20.10.21-dind
    securityContext:
      privileged: true
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
    - name: docker-certs
      mountPath: /certs
  - name: kubectl
    image: bitnami/kubectl:1.28
    command:
    - sleep
    args:
    - 99d
    securityContext:
      runAsNonRoot: true
      runAsUser: 1001
  - name: helm
    image: alpine/helm:3.12.3
    command:
    - sleep
    args:
    - 99d
    securityContext:
      runAsNonRoot: true
      runAsUser: 1001
  - name: security-scanner
    image: aquasec/trivy:latest
    command:
    - sleep
    args:
    - 99d
    securityContext:
      runAsNonRoot: true
      runAsUser: 1001
  - name: compliance-checker
    image: quantumnest/compliance-scanner:latest
    command:
    - sleep
    args:
    - 99d
    securityContext:
      runAsNonRoot: true
      runAsUser: 1001
    env:
    - name: COMPLIANCE_STANDARDS
      value: "PCI-DSS,SOX,SOC2,ISO27001"
  volumes:
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
  - name: docker-certs
    emptyDir: {}
"""
        }
    }

    environment {
        // Application Configuration
        APP_NAME = 'quantumnest-backend'
        APP_VERSION = "${BUILD_NUMBER}"
        DOCKER_REGISTRY = 'registry.quantumnest.com'
        HELM_CHART_REPO = 'https://charts.quantumnest.com'
        
        // Environment Configuration
        DEV_NAMESPACE = 'quantumnest-dev'
        STAGING_NAMESPACE = 'quantumnest-staging'
        PROD_NAMESPACE = 'quantumnest-prod'
        
        // Security Configuration
        VAULT_ADDR = 'https://vault.quantumnest.internal:8200'
        VAULT_NAMESPACE = 'quantumnest'
        SONARQUBE_URL = 'https://sonarqube.quantumnest.internal'
        
        // Compliance Configuration
        COMPLIANCE_STANDARDS = 'PCI-DSS,SOX,SOC2,ISO27001'
        AUDIT_LOG_LEVEL = 'INFO'
        SECURITY_SCAN_THRESHOLD = 'HIGH'
        
        // Notification Configuration
        SLACK_CHANNEL = '#quantumnest-deployments'
        EMAIL_RECIPIENTS = 'platform-team@quantumnest.com,compliance@quantumnest.com'
        
        // ArgoCD Configuration
        ARGOCD_SERVER = 'https://argocd.quantumnest.com'
        ARGOCD_APP_NAME = 'quantumnest-production'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '50', daysToKeepStr: '30'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        ansiColor('xterm')
        skipDefaultCheckout(false)
        parallelsAlwaysFailFast()
    }

    triggers {
        // Trigger on main branch commits
        githubPush()
        // Nightly security scans
        cron('H 2 * * *')
    }

    stages {
        stage('Checkout & Validation') {
            steps {
                script {
                    // Checkout code
                    checkout scm
                    
                    // Validate branch protection
                    if (env.BRANCH_NAME == 'main') {
                        echo "‚úÖ Building main branch - production deployment enabled"
                    } else {
                        echo "‚ÑπÔ∏è Building feature branch - limited deployment scope"
                    }
                    
                    // Load pipeline configuration
                    def pipelineConfig = readYaml file: '.jenkins/pipeline-config.yml'
                    env.PIPELINE_CONFIG = writeJSON returnText: true, json: pipelineConfig
                }
                
                // Audit log entry
                sh '''
                    echo "$(date -Iseconds) | PIPELINE_START | ${BUILD_NUMBER} | ${GIT_COMMIT} | ${BRANCH_NAME} | ${BUILD_USER:-system}" >> /tmp/audit.log
                '''
            }
        }

        stage('Security & Compliance Checks') {
            parallel {
                stage('Secret Scanning') {
                    steps {
                        container('security-scanner') {
                            sh '''
                                echo "üîç Scanning for secrets and sensitive data..."
                                trivy fs --security-checks secret --format json --output secrets-report.json .
                                
                                # Check for high-severity secrets
                                if [ $(jq '.Results[].Vulnerabilities | length' secrets-report.json 2>/dev/null || echo 0) -gt 0 ]; then
                                    echo "‚ùå Secrets detected in code repository"
                                    jq '.Results[].Vulnerabilities[]' secrets-report.json
                                    exit 1
                                fi
                                
                                echo "‚úÖ No secrets detected"
                            '''
                        }
                    }
                }
                
                stage('License Compliance') {
                    steps {
                        container('compliance-checker') {
                            sh '''
                                echo "üìã Checking license compliance..."
                                
                                # Scan for license compatibility
                                compliance-scanner license-check \
                                    --standards ${COMPLIANCE_STANDARDS} \
                                    --output license-report.json \
                                    --fail-on-violation true
                                
                                echo "‚úÖ License compliance check passed"
                            '''
                        }
                    }
                }
                
                stage('Code Quality Analysis') {
                    steps {
                        script {
                            // SonarQube analysis
                            withSonarQubeEnv('QuantumNest-SonarQube') {
                                sh '''
                                    echo "üìä Running code quality analysis..."
                                    sonar-scanner \
                                        -Dsonar.projectKey=quantumnest-backend \
                                        -Dsonar.projectName="QuantumNest Backend" \
                                        -Dsonar.projectVersion=${BUILD_NUMBER} \
                                        -Dsonar.sources=src \
                                        -Dsonar.tests=tests \
                                        -Dsonar.coverage.exclusions="**/test/**,**/mock/**" \
                                        -Dsonar.qualitygate.wait=true
                                '''
                            }
                        }
                    }
                }
            }
        }

        stage('Build & Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh '''
                            echo "üß™ Running unit tests..."
                            
                            # Install dependencies
                            npm ci --only=production
                            
                            # Run unit tests with coverage
                            npm run test:unit -- --coverage --ci --watchAll=false
                            
                            # Generate test reports
                            npm run test:report
                            
                            echo "‚úÖ Unit tests completed"
                        '''
                        
                        // Publish test results
                        publishTestResults testResultsPattern: 'test-results.xml'
                        publishCoverage adapters: [
                            jacocoAdapter('coverage/jacoco.xml')
                        ], sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
                    }
                }
                
                stage('Integration Tests') {
                    steps {
                        sh '''
                            echo "üîó Running integration tests..."
                            
                            # Start test database
                            docker run -d --name test-db \
                                -e POSTGRES_DB=quantumnest_test \
                                -e POSTGRES_USER=test_user \
                                -e POSTGRES_PASSWORD=test_password \
                                -p 5432:5432 \
                                postgres:14-alpine
                            
                            # Wait for database to be ready
                            sleep 10
                            
                            # Run integration tests
                            npm run test:integration
                            
                            # Cleanup
                            docker stop test-db && docker rm test-db
                            
                            echo "‚úÖ Integration tests completed"
                        '''
                    }
                }
                
                stage('Security Tests') {
                    steps {
                        sh '''
                            echo "üõ°Ô∏è Running security tests..."
                            
                            # SAST (Static Application Security Testing)
                            npm run security:sast
                            
                            # Dependency vulnerability scan
                            npm audit --audit-level high
                            
                            # OWASP ZAP baseline scan
                            docker run -v $(pwd):/zap/wrk/:rw \
                                owasp/zap2docker-stable zap-baseline.py \
                                -t http://localhost:3000 \
                                -J zap-report.json \
                                -r zap-report.html
                            
                            echo "‚úÖ Security tests completed"
                        '''
                    }
                }
            }
        }

        stage('Build Docker Image') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    changeRequest()
                }
            }
            steps {
                container('docker') {
                    script {
                        // Build multi-stage Docker image
                        def image = docker.build("${DOCKER_REGISTRY}/${APP_NAME}:${APP_VERSION}")
                        
                        // Security scan of the built image
                        sh '''
                            echo "üîç Scanning Docker image for vulnerabilities..."
                            trivy image --format json --output image-scan.json ${DOCKER_REGISTRY}/${APP_NAME}:${APP_VERSION}
                            
                            # Check for critical vulnerabilities
                            CRITICAL_VULNS=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' image-scan.json)
                            HIGH_VULNS=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' image-scan.json)
                            
                            echo "Critical vulnerabilities: $CRITICAL_VULNS"
                            echo "High vulnerabilities: $HIGH_VULNS"
                            
                            # Fail if critical vulnerabilities found
                            if [ "$CRITICAL_VULNS" -gt 0 ]; then
                                echo "‚ùå Critical vulnerabilities found in Docker image"
                                jq '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")' image-scan.json
                                exit 1
                            fi
                            
                            # Warn if high vulnerabilities found
                            if [ "$HIGH_VULNS" -gt 5 ]; then
                                echo "‚ö†Ô∏è High number of high-severity vulnerabilities found"
                                jq '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")' image-scan.json
                            fi
                            
                            echo "‚úÖ Docker image security scan completed"
                        '''
                        
                        // Push image to registry
                        docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                            image.push()
                            image.push('latest')
                        }
                    }
                }
            }
        }

        stage('Deploy to Development') {
            when {
                not { branch 'main' }
            }
            steps {
                container('kubectl') {
                    script {
                        // Deploy to development environment
                        sh '''
                            echo "üöÄ Deploying to development environment..."
                            
                            # Update Kubernetes manifests
                            kubectl set image deployment/${APP_NAME} \
                                ${APP_NAME}=${DOCKER_REGISTRY}/${APP_NAME}:${APP_VERSION} \
                                -n ${DEV_NAMESPACE}
                            
                            # Wait for rollout to complete
                            kubectl rollout status deployment/${APP_NAME} -n ${DEV_NAMESPACE} --timeout=300s
                            
                            echo "‚úÖ Development deployment completed"
                        '''
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                container('helm') {
                    script {
                        // Deploy to staging using Helm
                        sh '''
                            echo "üöÄ Deploying to staging environment..."
                            
                            # Add Helm repository
                            helm repo add quantumnest ${HELM_CHART_REPO}
                            helm repo update
                            
                            # Deploy with Helm
                            helm upgrade --install ${APP_NAME} quantumnest/quantumnest-backend \
                                --namespace ${STAGING_NAMESPACE} \
                                --set image.tag=${APP_VERSION} \
                                --set environment=staging \
                                --set compliance.enabled=true \
                                --set security.scanEnabled=true \
                                --wait --timeout=10m
                            
                            echo "‚úÖ Staging deployment completed"
                        '''
                    }
                }
                
                // Run smoke tests
                sh '''
                    echo "üß™ Running staging smoke tests..."
                    
                    # Wait for application to be ready
                    sleep 30
                    
                    # Run smoke tests
                    npm run test:smoke -- --env=staging
                    
                    echo "‚úÖ Staging smoke tests passed"
                '''
            }
        }

        stage('Production Approval') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Multi-level approval for production deployment
                    def approvers = [
                        'platform-team-lead',
                        'security-officer',
                        'compliance-officer'
                    ]
                    
                    def approvalMessage = """
                    üö® Production Deployment Approval Required
                    
                    Application: ${APP_NAME}
                    Version: ${APP_VERSION}
                    Git Commit: ${GIT_COMMIT}
                    Branch: ${BRANCH_NAME}
                    
                    Security Scan: ‚úÖ Passed
                    Compliance Check: ‚úÖ Passed
                    Staging Tests: ‚úÖ Passed
                    
                    Please review and approve for production deployment.
                    """
                    
                    timeout(time: 24, unit: 'HOURS') {
                        input message: approvalMessage,
                              submitterParameter: 'APPROVER',
                              submitter: approvers.join(',')
                    }
                    
                    echo "‚úÖ Production deployment approved by: ${env.APPROVER}"
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // GitOps deployment via ArgoCD
                    sh '''
                        echo "üöÄ Triggering production deployment via ArgoCD..."
                        
                        # Update GitOps repository
                        git clone https://github.com/quantumnest/gitops-config.git
                        cd gitops-config
                        
                        # Update image tag in production values
                        yq eval '.image.tag = "'${APP_VERSION}'"' -i environments/prod/values.yaml
                        
                        # Commit and push changes
                        git add environments/prod/values.yaml
                        git commit -m "Deploy ${APP_NAME} version ${APP_VERSION} to production"
                        git push origin main
                        
                        echo "‚úÖ GitOps repository updated"
                    '''
                    
                    // Trigger ArgoCD sync
                    sh '''
                        echo "üîÑ Triggering ArgoCD sync..."
                        
                        # Login to ArgoCD
                        argocd login ${ARGOCD_SERVER} --username admin --password ${ARGOCD_PASSWORD}
                        
                        # Sync application
                        argocd app sync ${ARGOCD_APP_NAME} --timeout 600
                        
                        # Wait for sync to complete
                        argocd app wait ${ARGOCD_APP_NAME} --timeout 600
                        
                        echo "‚úÖ Production deployment completed via ArgoCD"
                    '''
                }
            }
        }

        stage('Post-Deployment Validation') {
            when {
                branch 'main'
            }
            parallel {
                stage('Health Checks') {
                    steps {
                        sh '''
                            echo "üè• Running production health checks..."
                            
                            # Wait for application to be ready
                            sleep 60
                            
                            # Health check endpoint
                            curl -f https://api.quantumnest.com/health || exit 1
                            
                            # Readiness check
                            curl -f https://api.quantumnest.com/ready || exit 1
                            
                            echo "‚úÖ Production health checks passed"
                        '''
                    }
                }
                
                stage('Performance Tests') {
                    steps {
                        sh '''
                            echo "‚ö° Running production performance tests..."
                            
                            # Load testing with k6
                            k6 run --vus 10 --duration 5m performance-tests/load-test.js
                            
                            echo "‚úÖ Performance tests completed"
                        '''
                    }
                }
                
                stage('Security Validation') {
                    steps {
                        sh '''
                            echo "üõ°Ô∏è Running production security validation..."
                            
                            # SSL/TLS check
                            testssl.sh --quiet https://api.quantumnest.com
                            
                            # Security headers check
                            curl -I https://api.quantumnest.com | grep -E "(Strict-Transport-Security|Content-Security-Policy|X-Frame-Options)"
                            
                            echo "‚úÖ Security validation completed"
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            // Archive artifacts
            archiveArtifacts artifacts: '**/*-report.json,**/*-report.html,**/test-results.xml', 
                           allowEmptyArchive: true
            
            // Audit logging
            sh '''
                echo "$(date -Iseconds) | PIPELINE_END | ${BUILD_NUMBER} | ${currentBuild.result} | ${BUILD_DURATION}" >> /tmp/audit.log
                
                # Send audit logs to centralized logging
                curl -X POST https://logs.quantumnest.internal/audit \
                    -H "Content-Type: application/json" \
                    -d @/tmp/audit.log
            '''
        }
        
        success {
            // Success notifications
            slackSend channel: env.SLACK_CHANNEL,
                     color: 'good',
                     message: """
                     ‚úÖ *Deployment Successful*
                     Application: ${APP_NAME}
                     Version: ${APP_VERSION}
                     Environment: ${env.BRANCH_NAME == 'main' ? 'Production' : 'Development'}
                     Duration: ${currentBuild.durationString}
                     """
            
            emailext subject: "‚úÖ QuantumNest Deployment Successful - ${APP_NAME} v${APP_VERSION}",
                    body: """
                    Deployment completed successfully.
                    
                    Application: ${APP_NAME}
                    Version: ${APP_VERSION}
                    Git Commit: ${GIT_COMMIT}
                    Build Duration: ${currentBuild.durationString}
                    
                    All security and compliance checks passed.
                    """,
                    to: env.EMAIL_RECIPIENTS
        }
        
        failure {
            // Failure notifications
            slackSend channel: env.SLACK_CHANNEL,
                     color: 'danger',
                     message: """
                     ‚ùå *Deployment Failed*
                     Application: ${APP_NAME}
                     Version: ${APP_VERSION}
                     Stage: ${env.STAGE_NAME}
                     Build: ${BUILD_URL}
                     """
            
            emailext subject: "‚ùå QuantumNest Deployment Failed - ${APP_NAME} v${APP_VERSION}",
                    body: """
                    Deployment failed in stage: ${env.STAGE_NAME}
                    
                    Application: ${APP_NAME}
                    Version: ${APP_VERSION}
                    Git Commit: ${GIT_COMMIT}
                    Build URL: ${BUILD_URL}
                    
                    Please check the build logs for details.
                    """,
                    to: env.EMAIL_RECIPIENTS
        }
        
        cleanup {
            // Cleanup workspace
            cleanWs()
        }
    }
}

